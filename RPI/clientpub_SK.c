//COMPILE: gcc clientpub_SK.c -o clientpub_sk -lpaho-mqtt3c BearSSL/build/libbearssl.a 

//RUN: ./clientpub_sk

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/time.h>
#include "MQTTClient.h"
#include "BearSSL/inc/bearssl.h"

//#define ADDRESS     "ssl://192.168.12.232:8883"
#define ADDRESS     "tcp://192.168.12.232:2222"
#define CLIENTID    "ExampleClientPub"
#define TOPIC1       "mhh_my_topic"
#define TOPIC2       "mhh_sec_key"
#define QOS         1
#define TIMEOUT     10000L



#define DBUG

/* print the time measurment */ 
#define TIME_DEBUG

/* by enable   that we enforrce the connection to be closed after  each transmission */
//#define RECON


//#define CRY_DEBUG

//#define CRY_DEBUG_AES

//#define CRY_DEBUG_RSA_SIGN

#define BLOCK_SIZE 16


/*size of the message */
//#define Size_Byte 1024

//#define OSLOENABLE

 //uint8_t * mymsg; 
 
int Size_Byte =0;
 
  /* symetric key to encrypt the date*/
 uint8_t key[BLOCK_SIZE] = { 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

 /* Initial Value for encryption */  
//uint8_t iv[BLOCK_SIZE] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

/*
 * Key Store Public key 
 */
 unsigned char KS_RSA_N[] = {
    0x00,0xd7,0xbc,0xa7,0xf9,0xad,0x17,0xb4,0x61,0x04,0x77,0x5c,0xd5,0x41,0x26,
    0x15,0xed,0xc1,0x03,0x4c,0x82,0x99,0xae,0x4b,0x12,0xce,0x4b,0x60,0xa6,0xb8,
    0xea,0x9b,0xd1,0xb6,0x00,0x8c,0x2e,0x2c,0xe4,0x39,0x9d,0xc5,0x6f,0x4c,0x6c,
    0x0f,0x0e,0x41,0x53,0x89,0x24,0x50,0x0b,0xad,0xd4,0x1e,0x83,0xf6,0xb0,0xb8,
    0xbd,0xf1,0x94,0x83,0xd9,0x4e,0x24,0xe0,0xde,0xf6,0xf0,0x44,0x8a,0xf7,0xfe,
    0x5d,0x80,0x71,0xe4,0xc0,0x75,0xf3,0x09,0x1e,0x96,0xdd,0x20,0x9f,0x35,0x99,
    0xc5,0x10,0x7d,0xcb,0x6c,0xb5,0x85,0x24,0x6e,0x90,0xba,0xc7,0xc8,0x67,0x81,
    0x43,0x46,0xba,0x0d,0x98,0xe8,0xe1,0x2d,0x3b,0x22,0x7b,0x8f,0x10,0x34,0x6f,
    0xb0,0xe3,0x22,0xe6,0x7b,0xe6,0x81,0xc9,0x83
};
unsigned char KS_RSA_E[] = {
  0x01, 0x00, 0x01
};
static const br_rsa_public_key KS_RSA_PK = {
  KS_RSA_N, sizeof KS_RSA_N,
  KS_RSA_E, sizeof KS_RSA_E
};

/*
 * IOT RSA public and prrivate keys generated by openssl 
 */
 unsigned char RSA_N[] = {
    0x00,0xba,0xb8,0x44,0xe5,0xf9,0xbb,0x95,0x8e,0xad,0xc2,0xb9,0x67,0xca,0x8f,
    0xaf,0x4e,0x1c,0xd1,0x10,0xa0,0x5a,0x8c,0xf1,0x92,0xe1,0x10,0x07,0x43,0x3a,
    0xf5,0x3a,0xdf,0xad,0x7a,0xac,0x94,0x9e,0xeb,0x97,0xc4,0xb8,0x0f,0x5c,0xd6,
    0x03,0xe9,0x50,0xfb,0xf4,0x82,0x89,0xbc,0xf6,0x63,0xbd,0x38,0xda,0xf2,0x14,
    0x51,0x1d,0x99,0x7c,0x41,0xbb,0xd3,0x61,0x11,0x8e,0x47,0x56,0x0c,0x80,0x47,
    0x01,0x3c,0xa3,0xab,0x55,0xce,0x68,0xc0,0x4f,0x7c,0xee,0x7b,0x21,0xd0,0xa6,
    0x6d,0x1a,0xa9,0x37,0x93,0x5d,0xbe,0xed,0x64,0x92,0xce,0x35,0x5e,0x1e,0x9f,
    0x79,0x43,0xb8,0xd9,0x59,0xb5,0xd3,0x94,0x31,0xae,0x82,0xe2,0xbf,0x0e,0x0f,
    0x1a,0x45,0x0e,0xda,0x82,0xff,0x08,0x73,0x2f
};
unsigned char RSA_E[] = {
  0x01, 0x00, 0x01
};
  unsigned char RSA_P[] = {
  0x00,0xeb,0xc4,0xcf,0x5a,0xa1,0x72,0xa9,0x50,
  0x6c,0x3e,0xad,0x7c,0xb8,0xab,0x62,0x40,0x9b,
  0x8f,0xb7,0x6a,0x70,0xb1,0x96,0x4d,0x4e,0x7f,
  0x7a,0xa7,0x20,0x4c,0x99,0x55,0x1b,0xa9,0x8f,0x62,0x0e,0x7d,0x0a,0xae,
  0xf2,0x97,0xcf,0xb7,0x34,0xfc,0xf6,0x75,0x11,0x52,0x2d,0xfd,0x99,0x97,0xf4,0x80,0x8b,0x4a,0xab,0x20,0x75,0xa5,0xcc,0x59 
};
  unsigned char RSA_Q[] = {
    0x00,0xca,0xbd,0xfc,0xf9,0x58,0xe9,0xd7,0xe2,0x02,0x10,0xc2,0xc5,0x89,0x8e,
    0x32,0xde,0x96,0x90,0xf8,0xcc,0x5b,0x96,0x52,0x1b,0x8b,0x45,0xda,0x36,0xcc,
    0xae,0x93,0x21,0xcd,0x61,0x7b,0x84,0x65,0x5e,0x43,0x06,0x05,0x87,0x00,0x1b,
    0x99,0x21,0x99,0x11,0xf7,0xef,0xba,0xfe,0xf7,0x73,0x08,0xb0,0xdb,0x5e,0xa6,
    0x5b,0xa0,0xa0,0x2a,0xc7
};
 unsigned char RSA_DP[] = {0x00,0x96,0xd6,0xd6,0xb6,0xac,0x3e,0x18,0x97,0x0c,0x79,
 0xd9,0x32,0xc7,0x4f,0x56,0xcf,0xf0,0xf6,0xb4,0xa9,0x13,0xaa,0x7a,0x77,0xc1,0x36,
 0x0b,0xf9,0xaa,0xcf,0x76,0xf6,0x1d,0x79,0x90,0xf3,0x72,0x43,0x8b,0xb7,0x3c,0x1b,
 0xe6,0x57,0xd7,0x3d,0xd4,0x4c,0x37,0xa5,0xb5,0x28,0xdf,0xc0,0x79,0x3c,0x58,0x61,
 0x90,0x34,0x77,0x30,0x79,0x19
};
 unsigned char RSA_DQ[] = {
  0x5d,0x3e,0xf0,0x60,0xc6,0x52,0x16,0xe6,0x6d,0xc8,0xc3,
  0xac,0x12,0xce,0x01,0xfb,0x7a,0x08,0x87,0x45,0x86,0x42,
  0x26,0xd5,0x60,0x42,0xea,0x50,0x15,0xe7,0x9c,0xe8,0x09,
  0x0b,0xf2,0xc1,0x3b,0xd6,0x14,0xc1,0x6a,0x3d,0x63,0x01,
  0x4e,0x76,0xb3,0x6e,0x1e,0x38,0x76,0x2a,0xda,0x28,0x60,
  0x30,0xe7,0x54,0x2a,0xf3,0x2d,0x77,0x3c,0xf5
};
 unsigned char RSA_IQ[] = {
  0x00,0xc5,0xd7,0x18,0x69,0x9b,0xb9,0x48,0xa6,0xde,0x5c,0x19,0xc6,0xb0,0xc6,
  0xf3,0x0f,0xb7,0x53,0xdd,0xc1,0x09,0x08,0xf1,0x77,0xce,0xa4,0x63,0xdb,0x63,
  0x7d,0xe5,0x14,0xc2,0x47,0x56,0x8c,0xe8,0x39,0xe9,0xb1,0x10,0x6d,0x76,0x57,
  0xe8,0x9f,0x57,0xf1,0xa8,0x77,0xcb,0xc1,0xee,0x29,0xd3,0x10,0x23,0xf3,0xd9,
  0x44,0x79,0xd9,0xe2,0x78
};

static const br_rsa_public_key RSA_PK = {
  RSA_N, sizeof RSA_N,
  RSA_E, sizeof RSA_E
};

static const br_rsa_private_key RSA_SK = {
  1024,
  RSA_P, sizeof RSA_P,
  RSA_Q, sizeof RSA_Q,
  RSA_DP, sizeof RSA_DP,
  RSA_DQ, sizeof RSA_DQ,
  RSA_IQ, sizeof RSA_IQ
};

static const unsigned char SHA1_OID[] = {
  0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A
};


/*
 * Print array
 * size: the size of the array 
 * beg: index to start printing 
 */
  void dbgPrint(uint8_t * arr, int size, int beg)
{

  int start = beg; //defualt = 0
  int row =0 ;
  printf(" %d >> ", row);  
  for (int i =start; i<size; i++)
  {
     if(i> 0 && i % BLOCK_SIZE ==0)
     {
      row++;
      printf("\n");
      printf(" %d >> ", row);  
     }
     printf("  %x ", arr[i]); 
   
  }
  printf("\n");
    
  }
  
/*
 *  function for RSA encryption 
 */
typedef struct {
  const br_prng_class *vtable;
  unsigned char buf[128];
  size_t ptr, len;
} rng_fake_ctx;

 void rng_fake_init(rng_fake_ctx *cc, const void *params, const void *seed, size_t len);
 void rng_fake_generate(rng_fake_ctx *cc, void *dst, size_t len);
 void rng_fake_update(rng_fake_ctx *cc, const void *src, size_t len);

 const br_prng_class rng_fake_vtable = {
  sizeof(rng_fake_ctx),
  (void (*)(const br_prng_class **,
    const void *, const void *, size_t))&rng_fake_init,
  (void (*)(const br_prng_class **,
    void *, size_t))&rng_fake_generate,
  (void (*)(const br_prng_class **,
    const void *, size_t))&rng_fake_update
};

 void rng_fake_init(rng_fake_ctx *cc, const void *params, const void *seed, size_t len)
{
  (void)params;
  if (len > sizeof cc->buf) {
    printf("seed is too large ( %d bytes) \n", (unsigned long)len);
    exit(EXIT_FAILURE);
  }
  cc->vtable = &rng_fake_vtable;
  memcpy(cc->buf, seed, len);
  cc->ptr = 0;
  cc->len = len;
}

 void rng_fake_generate(rng_fake_ctx *cc, void *dst, size_t len)
{
  if (len > (cc->len - cc->ptr)) {
   // fprintf(stderr, "asking for more data than expected\n");
    exit(EXIT_FAILURE);
  }
  memcpy(dst, cc->buf + cc->ptr, len);
  cc->ptr += len;
}

 void rng_fake_update(rng_fake_ctx *cc, const void *src, size_t len)
{
 
}
int 
check_equals(const char *banner, const void *v1, const void *v2, size_t len)
{
  
  unsigned char *b;

  if (memcmp(v1, v2, len) == 0) {
    return 0;
  }
  else 
  return -1; 
}

size_t hextobin(unsigned char *dst, const char *src)
{
  size_t num;
  unsigned acc;
  int z;

  num = 0;
  z = 0;
  acc = 0;
  while (*src != 0) {
    int c = *src ++;
    if (c >= '0' && c <= '9') {
      c -= '0';
    } else if (c >= 'A' && c <= 'F') {
      c -= ('A' - 10);
    } else if (c >= 'a' && c <= 'f') {
      c -= ('a' - 10);
    } else {
      continue;
    }
    if (z) {
      *dst ++ = (acc << 4) + c;
      num ++;
    } else {
      acc = c;
    }
    z = !z;
  }
  return num;
}

/*
 * RSA SIGNING
 * signedhash (128)
 */
void rsa_sign( char * msg ,  unsigned char * signedhash,  br_rsa_pkcs1_sign fsign)
    {
      struct timeval start, end;
      #ifdef CRY_DEBUG_RSA_SIGN
       printf("<<<<<<<<<<<<<Start Sign>>>>>>>>>>>>>>>>>>>\n");
      #endif
      
      unsigned char hv[20];
      br_sha1_context hc;
      size_t u;

      br_sha1_init(&hc);
      br_sha1_update(&hc, msg, strlen(msg));
      br_sha1_out(&hc, hv);
     
      #ifdef CRY_DEBUG_RSA_SIGN
      printf("Hash Value :"); 
      dbgPrint(hv, 20, 0 ); 
      #endif
      gettimeofday(&start, NULL);
      if (!fsign(SHA1_OID, hv, 20, &RSA_SK, signedhash)) {
	printf("Signature generation failed\n");
      }
     gettimeofday(&end, NULL);
      
      #ifdef TIME_DEBUG
	//printf(" Time to sign: %d us \n", (end.tv_usec - start.tv_usec)); 
	 printf("\t%d\t",(end.tv_usec - start.tv_usec));
      #endif
      
      #ifdef CRY_DEBUG_RSA_SIGN
      printf(" signature :"); 
      dbgPrint(signedhash, 128, 0); 
      printf("<<<<<<<<<<<<<End Sign>>>>>>>>>>>>>>>>>>\n"); 
      #endif
  }
  
/*
 * RSA Encryption 
 */
//int  rsa_encrypt(char * plaintext, unsigned char * output, br_rsa_oaep_encrypt menc)
int  rsa_encrypt(unsigned char * plaintext, unsigned char * output, br_rsa_oaep_encrypt menc)
  {
	struct timeval start, end;
        #ifdef CRY_DEBUG
	   printf("<<<<<<<<<<<<<Start RSA Encryption>>>>>>>>>>>>>>>>>>\n"); 
        #endif
	char * arrn = "BBF82F090682CE9C2338AC2B9DA871F7368D07EED41043A440D6B6F07454F51FB8DFBAAF035C02AB61EA48CEEB6FCD4876ED520D60E1EC4619719D8A5B8B807FAFB8E0A3DFC737723EE6B4B7D93A2584EE6A649D060953748834B2454598394EE0AAB12D7B61A51F527A9A41F6C1687FE2537298CA2A8F5946F8E5FD091DBDCB";
	char * expo = "11";
	char * seedar  = "AAFD12F659CAE63489B479E5076DDEC2F06CB58F" ; 
	
	unsigned char  seed[128];
	size_t plain_len, seed_len ;
	rng_fake_ctx rng;
	
	unsigned char n[512];
	unsigned char e[8];
	
	br_rsa_public_key pk;

	pk.n = n;
	pk.nlen = hextobin(n, arrn);
	pk.e = e;
	pk.elen = hextobin(e, expo);
	unsigned char tmp[513];
	size_t len;

	plain_len = BLOCK_SIZE;
	//plain_len = hextobin(plain,plaintext);
	#ifdef CRY_DEBUG
	 printf("Session Key: ");
	 //dbgPrint( plain, plain_len, 0 ); 
	 dbgPrint( plaintext, plain_len, 0 ); 
	#endif
	 
	 seed_len = hextobin(seed, seedar);
	 
	 // #ifdef CRY_DEBUG
	 // printf("Seed: "); 
	 //  dbgPrint(seed, seed_len, 0); 
	 // #endif
	 
	  rng_fake_init(&rng, NULL, seed, seed_len);
	  
	 
	  gettimeofday(&start, NULL);
	  len = menc(&rng.vtable, &br_sha1_vtable, NULL, 0, &pk, tmp, sizeof tmp, plaintext, plain_len);
	  gettimeofday(&end, NULL);
	
	  
	
	 if (len == 0 )
	 {
	    #ifdef CRY_DEBUG
	    printf("Encryption failed ! \n");
	    #endif
	    return -1; 
	 }
	  
	#ifdef CRY_DEBUG
	printf("Encryption succeeded ! \n ");  
	printf ("Encryptted key: \n"); 
	dbgPrint(tmp, len, 0);
	#endif
	
    
	for (int i = 0 ; i<len; i++)
	    output[i] = tmp[i]; 

	#ifdef TIME_DEBUG
	    //printf (" Time to Encrypt the  session key using RSA: %d us \n", (end.tv_usec - start.tv_usec)); 
	    printf("%d\t",(end.tv_usec - start.tv_usec));
	#endif
	#ifdef CRY_DEBUG
	printf("<<<<<<<<<<<<<END RSA Encryption>>>>>>>>>>>>>>>>>>\n");  
	#endif
	return len; 
  }


int rsa_decrypt(unsigned char * cipher,  br_rsa_oaep_decrypt mdec)
{

	printf("<<<<<<<<<<<<<Start RSA Decryption>>>>>>>>>>>>>>>>>>\n");
	
	char * seedar  = "AAFD12F659CAE63489B479E5076DDEC2F06CB58F" ; 

	char * parr  = "EECFAE81B1B9B3C908810B10A1B5600199EB9F44AEF4FDA493B81A9E3D84F632124EF0236E5D1E3B7E28FAE7AA040A2D5B252176459D1F397541BA2A58FB6599";
	char * qarr  = "C97FB1F027F453F6341233EAAAD1D9353F6C42D08866B1D05A0F2035028B9D869840B41666B42E92EA0DA3B43204B5CFCE3352524D0416A5A441E700AF461503";
	char * dparr = "54494CA63EBA0337E4E24023FCD69A5AEB07DDDC0183A4D0AC9B54B051F2B13ED9490975EAB77414FF59C1F7692E9A2E202B38FC910A474174ADC93C1F67C981";
	char * dqarr = "471E0290FF0AF0750351B7F878864CA961ADBD3A8A7E991C5C0556A94C3146A7F9803F8F6F8AE342E931FD8AE47A220D1B99A495849807FE39F9245A9836DA3D";
	char * iqarr=   "B06C4FDABB6301198D265BDBAE9423B380F271F73453885093077FCD39E2119FC98632154F5883B167A967BF402B4E9E2E0F9656E698EA3666EDFB25798039F7";


	unsigned char p[256];
	unsigned char q[256];
	unsigned char dp[256];
	unsigned char dq[256];
	unsigned char iq[256];
	unsigned char  seed[128];
	br_rsa_private_key sk;

	sk.n_bitlen = 1024;
	sk.p = p;
	sk.plen = hextobin(p, parr);
	sk.q = q;
	sk.qlen = hextobin(q, qarr);
	sk.dp = dp;
	sk.dplen = hextobin(dp, dparr);
	sk.dq = dq;
	sk.dqlen = hextobin(dq, dqarr);
	sk.iq = iq;
	sk.iqlen = hextobin(iq, iqarr);

	//size_t len = hextobin(cipher, tmp);
	printf(" Cipher text : \n");
	dbgPrint(cipher, 128, 0); 
	
	size_t len = 128;
	if (mdec(&br_sha1_vtable, NULL, 0,  &sk, cipher, &len) != 1)
	  {
	    printf("decryption failed");
	    return  -1; 
	  }
	printf("len after: %d \n", len);
	
	 dbgPrint(cipher, len , 0); 
	  
	 
     printf("<<<<<<<<<<<<<END RSA DEcryption >>>>>>>>>>>>>>>>>>\n");  
  }
/*
* Generate  random text
*/
static uint8_t  *rand_string(uint8_t  *str, size_t size)
{
    const char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXZY";
    if (size) {
        for (size_t n = 0; n < size; n++) {
            int key = rand() % 16;
            str[n] = key;
	    //printf( " id = %d  , %u \n",n,   str[n]);
        }
    }
    return str;
}

uint8_t * rand_string_alloc(size_t size)
{
     uint8_t  *s =(uint8_t  *) malloc(size);
     if (s) {
         rand_string(s, size);
     }
     return s;
}

  

  
  /*
 * Encrypt message pt (plain text) using the defined key and store the encrypted inplace
 */
 void encryption(uint8_t * pt)
{
      struct timeval start, end;
      uint8_t iv[BLOCK_SIZE] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

      br_aes_big_cbcenc_keys    ctx ; 
      #ifdef CRY_DEBUG_AES
      printf(" <<<<<<<<<<<<<<<start AES Encryption>>>>>>>>>>>>>>>>>\n");
      printf(" Plain Text for AES \n");
      dbgPrint(pt,Size_Byte,Size_Byte-32);
      #endif
     
      br_aes_big_cbcenc_init(&ctx, key,BLOCK_SIZE ); 
      #ifdef OSLOENABLE
      digitalWrite(13, HIGH); 
      #endif
      gettimeofday(&start, NULL);
     
      br_aes_big_cbcenc_run(&ctx,iv,  pt, Size_Byte);
	
     gettimeofday(&end, NULL);
     #ifdef OSLOENABLE
     digitalWrite(13, LOW);
     #endif
     #ifdef TIME_DEBUG
      //printf("Time to Encrypt the Data using AES is: %d us \n", (end.tv_usec - start.tv_usec)); 
      printf("\t%d\t", (end.tv_usec - start.tv_usec));
     #endif
	
     #ifdef CRY_DEBUG_AES
      printf(" Encryptted text by AES: \n");
      dbgPrint(pt,Size_Byte,Size_Byte-32);
      printf("<<<<<<<<<<<<<<<End AES Encryption>>>>>>>>>>>>>>>>>\n");
      #endif
  }
  
  
/* 
 *  adjust the length of the ciphered text

void bufferSize(char* text, int *length)
{
  int i = strlen(text);
  int buf = round(i / BLOCK_SIZE) * BLOCK_SIZE;
  length = (buf <= i) ? buf + BLOCK_SIZE : length = buf;
}

 */
/*
 * Comvert Unsigned char to char *
 */
void uninttochar(char * output,  uint8_t * input, int lenght)
{
    //pritnf(" line is %d \n ", lenght); 
    char *  k = output; 
    for (int i = 0 ;i<lenght; i++) 
    { 
        //Serial.print(i); 
	//Serial.print(" >> ");
	// Serial.println(input[i], HEX); 
       sprintf(k, "%02X",(uint8_t)input[i]); 
       k+=2;
    }
     k[lenght]= '\0';
}
 void Datatransmission(unsigned char * msg, int value, MQTTClient client)
 {
     
      encryption(msg);
      struct timeval start, end;
      MQTTClient_message pubmsg = MQTTClient_message_initializer;
      MQTTClient_deliveryToken token;
      int rc ; 
      
      gettimeofday(&start, NULL);
      
      pubmsg.payload = msg;
      pubmsg.payloadlen = Size_Byte;
      pubmsg.qos = QOS;
      pubmsg.retained = 0;
      MQTTClient_publishMessage(client, TOPIC1, &pubmsg, &token);
      rc = MQTTClient_waitForCompletion(client, token, TIMEOUT);
      gettimeofday(&end, NULL);
      
      #ifdef TIME_DEBUG
      // printf("Msg %d  was sent !\n", value); 
       //printf("Time  send %d Data = %d  us \n", Size_Byte, (end.tv_usec - start.tv_usec)); 
       printf("\t%d\t",(end.tv_usec - start.tv_usec));
     #endif
     
  
     
 }
 
 void Keytransmission(int value, MQTTClient client)
 {
     
    
      struct timeval start, end;
      MQTTClient_message pubmsgkey = MQTTClient_message_initializer;
      MQTTClient_deliveryToken token;
      int rc ; 
      
      gettimeofday(&start, NULL);
      
      pubmsgkey.payload = key;
      pubmsgkey.payloadlen = BLOCK_SIZE;
      pubmsgkey.qos = QOS;
      pubmsgkey.retained = 0;
      MQTTClient_publishMessage(client, TOPIC2, &pubmsgkey, &token);
     
      gettimeofday(&end, NULL);
      
      #ifdef TIME_DEBUG
	//printf("key for msg %d  was sent !\n", value); 
	//printf("Time  send the session key = %d  us\n", (end.tv_usec - start.tv_usec)); 
	printf("\t%d\t",(end.tv_usec - start.tv_usec));
     #endif
     
     rc = MQTTClient_waitForCompletion(client, token, TIMEOUT);
     
 }
 
 void SesKeytransmission(int value, MQTTClient client)
 {
	struct timeval start, end;
	MQTTClient_message pubmsgkey = MQTTClient_message_initializer;
	MQTTClient_deliveryToken token;
	int rc ; 
        
	int siglength = 128; 
	
	unsigned char cipher[513] = {0};
	
	char * credintial = " KeyNote-Version: 2\n"\
           "Authorizer: \"RSA:dab212\" \n" \     
           "Licensees: \"DSA:feed1234\" \n"\
           "Conditions: (app_domain==\"KS\")-> { (Process) < 2500) -> _MAX_TRUST;"\
           "Signature: ";
	unsigned char signnature [siglength]; 

	//sign the credintial 
	rsa_sign(credintial, signnature,  &br_rsa_i15_pkcs1_sign);
	
	#ifdef CRY_DEBUG
	printf("Session Key: ");
	dbgPrint(key, 16, 0); 
        printf("sizeof(cipher) :%d \n", sizeof(cipher));
	#endif 
	
       int len = rsa_encrypt(key, cipher, &br_rsa_i15_oaep_encrypt);
       #ifdef CRY_DEBUG
	printf("Encryptted Key (%d):\n", len);
	dbgPrint (cipher, len, 0); 
       #endif
       
       
      int lenght  = len + siglength+ strlen(credintial); 
      unsigned char buff[lenght];
      strncpy(buff,cipher,len); 
      strncpy(buff+len,signnature,siglength); 
      strncpy(buff+len+siglength,credintial, strlen(credintial));  
      
      
    
      pubmsgkey.payload = buff;
      pubmsgkey.payloadlen = lenght;
      pubmsgkey.qos = QOS;
      pubmsgkey.retained = 0;
      gettimeofday(&start, NULL);
      
    
      MQTTClient_publishMessage(client, TOPIC2, &pubmsgkey, &token);
      rc = MQTTClient_waitForCompletion(client, token, TIMEOUT);
      
      gettimeofday(&end, NULL);
      
      #ifdef TIME_DEBUG
	//printf("key for msg %d  was sent !\n", value); 
	//printf("Time  send the session key = %d us \n", (end.tv_usec - start.tv_usec)); 
	printf("\t%d\t",(end.tv_usec - start.tv_usec));
      #endif
     
     
     //rsa_decrypt (cipher, &br_rsa_i15_oaep_decrypt);
     
     
 }
  
  void SesKeytransmission_old(int value, MQTTClient client)
 {
	struct timeval start, end;
	MQTTClient_message pubmsgkey = MQTTClient_message_initializer;
	MQTTClient_deliveryToken token;
	int rc ; 
     
	
	unsigned char cipher[513] = {0};
	/*
	int keylen = (sizeof key);
	char keyse[keylen+1] ; 
	uninttochar (keyse, key, keylen);
        */
	#ifdef CRY_DEBUG
	printf("Session Key: ");
	dbgPrint(key, 16, 0); 
        printf("sizeof(cipher) :%d \n", sizeof(cipher));
	#endif 
	
       int len = rsa_encrypt(key, cipher, &br_rsa_i15_oaep_encrypt);
       #ifdef CRY_DEBUG
	printf("Encryptted Key (%d):\n", len);
	dbgPrint (cipher, len, 0); 
       #endif
       
      gettimeofday(&start, NULL);
      
      pubmsgkey.payload = cipher;
      pubmsgkey.payloadlen = len;
      pubmsgkey.qos = QOS;
      pubmsgkey.retained = 0;
      
    
      MQTTClient_publishMessage(client, TOPIC2, &pubmsgkey, &token);
      rc = MQTTClient_waitForCompletion(client, token, TIMEOUT);
      
      gettimeofday(&end, NULL);
      
      #ifdef TIME_DEBUG
	printf("key for msg %d  was sent !\n", value); 
	printf("Time  send the session key = %d us \n", (end.tv_usec - start.tv_usec)); 
      #endif
     
     
     //rsa_decrypt (cipher, &br_rsa_i15_oaep_decrypt);
     
     
 }
int main(int argc, char* argv[])
{
    int value = 0 ; 
    MQTTClient client;
    MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;
    MQTTClient_create(&client, ADDRESS, CLIENTID,
    MQTTCLIENT_PERSISTENCE_NONE, NULL);
    conn_opts.keepAliveInterval = 20;
    conn_opts.cleansession = 1;
    int rc; 

    struct timeval curTime, lastTime;
    struct timeval start, end;
    
    gettimeofday(&lastTime, NULL);
    
    printf("Size\tMSG_Id\tTTconnect\tTTsign\tTTenckey\tTTsendkey\tTTencydata\tTTsendDate\n", rc);
    int sizes[] = {1024, 5120,10240,15360,20480,25600};
    for (int ind= 0; ind<6; ind++)
    {
	Size_Byte = sizes[ind]; 
	
	uint8_t * mymsg  =rand_string_alloc(Size_Byte);
	value =0; 

       while(1==1)
       {
	    gettimeofday(&curTime, NULL);
	    if ( curTime.tv_sec - lastTime.tv_sec  > 10) 
	    {
		    lastTime = curTime;
		    value ++;
		    if ( !MQTTClient_isConnected(client))
		    {
			    gettimeofday(&start, NULL);
			    if ((rc = MQTTClient_connect(client, &conn_opts)) != MQTTCLIENT_SUCCESS)
			    {
				    printf("Failed to connect, return code %d\n", rc);
				    exit(-1);
			    }
			    gettimeofday(&end, NULL);
			    #ifdef TIME_DEBUG
				printf("%d\t%d\t%d\t",Size_Byte, value,(end.tv_usec - start.tv_usec)); 
				//printf("Time to connect = %d  us \n", (end.tv_usec - start.tv_usec)); 
			    #endif
		    }
		     
		    SesKeytransmission(value, client); 
		    
		    Datatransmission(mymsg, value, client);
		    
		     
		    MQTTClient_disconnect(client, 10000);
		    printf("\n");
	  
	}
	    if(value >20)
		break; 
	   
	}
	printf("--------------------------------\n");
	free(mymsg);
    }
     MQTTClient_destroy(&client);
    return rc;
}

